## Student Name: Avery Backus
## Student ID: 219767888

Prompt 1: "solution.py: ## Student Name: ## Student ID: """ Stub file for the is allocation feasible exercise. Implement the function is_allocation_feasible to Determine whether a set of resource requests can be satisfied given limited capacities. Take int account any possible constraints. See the lab handout for full requirements. """ from typing import Dict, List, Union Number = Union[int, float] def is_allocation_feasible( resources: Dict[str, Number], requests: List[Dict[str, Number]] ) -> bool: """ Determine whether a set of resource requests can be satisfied given limited capacities. Args: resources : Dict[str, Number], Mapping from resource name to total available capacity. requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required. Returns: True if the allocation is feasible, False otherwise. """ # TODO: Implement this function raise NotImplementedError("suggest_slots function has not been implemented yet") test_solution.py: ## Student Name: ## Student ID: """ Public test suite for the meeting slot suggestion exercise. Students can run these tests locally to check basic correctness of their implementation. The hidden test suite used for grading contains additional edge cases and will not be available to students. """ from solution import is_allocation_feasible import pytest def test_basic_feasible_single_resource(): # Basic Feasible Single-Resource # Constraint: total demand <= capacity # Reason: check basic functional requirement resources = {'cpu': 10} requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}] assert is_allocation_feasible(resources, requests) is True def test_multi_resource_infeasible_one_overloaded(): # Multi-Resource Infeasible (one overload) # Constraint: one resource exceeds capacity # Reason: check detection of per-resource infeasibility resources = {'cpu': 8, 'mem': 30} requests = [{'cpu': 2, 'mem': 8}, {'cpu': 3, 'mem': 10}, {'cpu': 3, 'mem': 14}] assert is_allocation_feasible(resources, requests) is False def test_missing_resource_in_availability(): # Missing Resource in Requests # Constraint: request references unavailable resource # Reason: allocation must be infeasible resources = {'cpu': 10} requests = [{'cpu': 2}, {'gpu': 1}] assert is_allocation_feasible(resources, requests) is False def test_non_dict_request_raises(): # Non-Dict Request Raises Error # Constraint: structural validation # Reason: request must be a dict resources = {'cpu': 5} requests = [{'cpu': 2}, ['mem', 1]] # malformed request with pytest.raises(ValueError): is_allocation_feasible(resources, requests) """TODO: Add at least 5 additional test cases to test your implementation.""""

LLM Response 1: "ere’s a solid implementation of is_allocation_feasible that passes the given public tests and handles common edge cases cleanly (type/shape validation, negative amounts, unknown resources, etc.).

solution.py
from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Rules implemented (based on the public tests + sensible constraints):
      - resources must be a dict[str, number] with non-negative capacities
      - requests must be a list of dict[str, number]
      - each request amount must be non-negative
      - if any request references a resource not present in resources -> infeasible (False)
      - allocation is feasible iff for every resource r:
            sum(request_i.get(r, 0)) <= resources[r]

    Returns:
        True if feasible, False otherwise.

    Raises:
        ValueError for malformed inputs (wrong types, non-numeric, negative values, etc.)
    """
    # Validate resources structure
    if not isinstance(resources, dict):
        raise ValueError("resources must be a dict mapping resource name to capacity")

    for k, v in resources.items():
        if not isinstance(k, str):
            raise ValueError("resource names in resources must be strings")
        if not isinstance(v, (int, float)):
            raise ValueError(f"capacity for resource '{k}' must be a number")
        if v < 0:
            raise ValueError(f"capacity for resource '{k}' must be non-negative")

    # Validate requests structure
    if not isinstance(requests, list):
        raise ValueError("requests must be a list of dicts")

    totals: Dict[str, float] = {r: 0.0 for r in resources}

    for idx, req in enumerate(requests):
        if not isinstance(req, dict):
            raise ValueError(f"request at index {idx} must be a dict")

        for rname, amount in req.items():
            if not isinstance(rname, str):
                raise ValueError(f"resource name in request at index {idx} must be a string")
            if not isinstance(amount, (int, float)):
                raise ValueError(f"amount for resource '{rname}' in request at index {idx} must be a number")
            if amount < 0:
                raise ValueError(f"amount for resource '{rname}' in request at index {idx} must be non-negative")

            if rname not in resources:
                # Requests a resource that doesn't exist in availability => infeasible
                return False

            totals[rname] += float(amount)

            # Early exit if we already exceed capacity
            if totals[rname] > float(resources[rname]):
                return False

    return True

Add at least 5 more tests (test_solution.py)

You can paste these under the existing tests:

def test_empty_requests_is_feasible():
    resources = {"cpu": 4, "mem": 8}
    requests = []
    assert is_allocation_feasible(resources, requests) is True


def test_exact_capacity_boundary_is_feasible():
    resources = {"cpu": 10}
    requests = [{"cpu": 4}, {"cpu": 6}]
    assert is_allocation_feasible(resources, requests) is True


def test_empty_resources_with_no_requests_is_feasible():
    resources = {}
    requests = []
    assert is_allocation_feasible(resources, requests) is True


def test_negative_request_amount_raises():
    resources = {"cpu": 10}
    requests = [{"cpu": -1}]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_negative_resource_capacity_raises():
    resources = {"cpu": -5}
    requests = [{"cpu": 1}]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_float_amounts_feasible():
    resources = {"cpu": 5.0, "mem": 3.5}
    requests = [{"cpu": 1.2, "mem": 1.0}, {"cpu": 3.8, "mem": 2.5}]
    assert is_allocation_feasible(resources, requests) is True


If you want, I can also add “nasty” edge-case tests (e.g., non-numeric amounts, non-string keys, requests not a list, etc.), but the above already covers a good spread for hidden cases."

--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------
